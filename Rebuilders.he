import Common
import State
import Track
import Utils
import Writer

import List

open Common
open State
open Track



(* -------------------------------------------- Mod Time -------------------------------------------- *)

(* type Time = Int *)
(* type MakeInfo (K: KeyOrder) = let type MK = Map K in Pair Time (MK.this K.this) *)

(* {i v: Type} (module T: KeyOrder) {`a: StoreEff i T.this v} (tasks: Tasks T.this v) (key: T.this) *)
(* type Rebuilder (IR: Type) (K: Type) (V: Type) = {State IR} -> K -> V -> TaskType K V ->[`s] TaskType K V *)

(* let modTimeRebuilder {V: Type} (module T: KeyOrder) (key: T.this) (value: V) (task: TaskType T.this V) =  *)
(*     let type MK = Map T in *)
(*     let (now, modTimes) = get () in *)
(*     let dirty = handle MK.find key modTimes with *)
(*                 | not_found _ =>  in 0 *)

(* -------------------------------------------- Dirty Bit ------------------------------------------- *)

let dirtyBitRebuilder {K V: Type} {`s: State (K -> Bool)} (module KV: KeyValue K V) (key: K) (value: V) (task: TaskType K V (effect [])) = Task (fn (`b: BuildEff K V) () =>
    let isDirty = get `s () in
    if isDirty key then run task
                   else value)

(* --------------------------------------------- Traces --------------------------------------------- *)

data TraceType (K V A: Type) = Trace of K, (List (Pair K (Hash V))), A

let hashedFetch hash =
    handler
    | fetch k => resume (hash (fetch k))
    end

(* ---------------------------------------- Verifying Traces ---------------------------------------- *)

type VT (K V: Type) = List (TraceType K V (Hash V))
type Deps (K V: Type) = List (Pair K (Hash V))

let recordVT {K V: Type} {`s: State (VT K V)} (key: K) (hash: Hash V) (deps: Deps K V) =
    modify (fn ts => (Trace key deps hash) :: ts)
    
let verifyVT {K V: Type} {`s: State (VT K V)} {`b: BuildEff K (Hash V)} (module KV: KeyValue K V) (key: K) (hash: Hash V) =
    let fetchedHashMatches (k, h) = h = fetch k in
    let matchFor (Trace k deps result) =
        if not (KV.Key.equals k key) || result <> hash then False
        else List.forAll fetchedHashMatches deps
    in List.exists matchFor (get ())

let vtRebuilder {K V: Type} {`s: State (VT K V)} (module KV: KeyValue K V) (key: K) (value: V) (task: TaskType K V (effect [])) = Task (fn (`b: BuildEff K V) () =>
    open KV.Value in
    let upToDate = handle verifyVT KV key (hash value) with hashedFetch hash in
        if upToDate then value
        else (let (newValue, deps) = track task in
                 recordVT key (hash newValue) (List.map (fn (k, v) => (k, hash v)) deps);
                 newValue))

(* I'll leave it for now, since when manually checking vtRebuilder's type
   there's an extra effect in returned Task, but it doesn't seem to matter
   in usage cases. At least for now... *)

(* let (vtRebuilder: {K V: Type} -> {`s: State (VT K V)} -> KeyValue K V ->[] K ->[] V ->[] TaskType K V (effect []) ->[] TaskType K V (effect [`s])) = vtRebuilder666 *)

(* --------------------------------------- Constructive Traces -------------------------------------- *)

(* This implementation of matchFor in constructCT loops: *)
(* if KV.Key.equals k key && List.forAll fetchedHashMatches deps *)
(* then Writer.tell result *)
(* else () *)

type CT (K V: Type) = List (TraceType K V V)

let recordCT {K V: Type} {`s: State (CT K V)} (key: K) (value: V) (deps: Deps K V) =
    modify (fn ts => (Trace key deps value) :: ts)

let constructCT {K V: Type} {`b: BuildEff K (Hash V)} (module KV: KeyValue K V) (key: K) (ts: CT K V) =
    let fetchedHashMatches (k, h) = h = fetch k in
    let matchFor {`r: Writer V} (Trace k deps result) =
        if not (KV.Key.equals k key) then ()
        else (let same = List.forAll fetchedHashMatches deps in
                  if same then Writer.tell result else ()) in
    let handle `r with Writer.listHandler in
        List.iter (matchFor `r) ts

let ctRebuilder {K V: Type} {`s: State (CT K V)} (module KV: KeyValue K V) (key: K) (value: V) (task: TaskType K V (effect [])) = Task (fn (`b: BuildEff K V) () =>
    open KV.Value in
    let cachedValues = handle constructCT KV key (get `s ()) with hashedFetch hash in
        if Utils.member KV.Value value cachedValues
        then value
        else match cachedValues with
             | (cachedValue::_) => cachedValue
             | [] => let (newValue, deps) = track task in
                         recordCT `s key newValue (List.map (fn (k, v) => (k, hash v)) deps);
                         newValue
             end)

(* ------------------------------------ Deep Constructive Traces ------------------------------------ *)

type DCT (K V: Type) = List (TraceType K V V)

let deepDependencies {K V: Type} (module KV: KeyValue K V) (ts: DCT K V) (valueHash: Hash V) (key: K) =
    open KV in
    let f (Trace k deps v) = if Key.equals k key && Value.hash v = valueHash
                             then Writer.tell (List.map fst deps)
                             else () in
    let depsList = handle `w in List.iter (f `w) ts with Writer.listHandler in
        match depsList with
        | []        => [key]
        | (deps::_) => deps (* Authors assume that there is only one record for a (k, v) pair *)
        end

let recordDCT {K V: Type} {`s: State (DCT K V)} {`b: BuildEff K (Hash V)} (module KV: KeyValue K V) (key: K) (value: V) (deps: List K) =
    open KV.Value in
    let deepDeps = Utils.concatMap (deepDependencies KV (get `s ()) (hash value)) deps in
    let hs = List.map (fetch `b) deepDeps in
    let depends = Utils.zip deepDeps hs in
        modify (fn ts => (Trace key depends value) :: ts)

let constructDCT {K V: Type} {`b: BuildEff K (Hash V)} (module KV: KeyValue K V) (key: K) (ts: DCT K V) = constructCT KV key ts

let dctRebuilder {K V: Type} {`s: State (DCT K V)} (module KV: KeyValue K V) (key: K) (value: V) (task: TaskType K V (effect [])) = Task (fn (`b: BuildEff K V) () =>
    open KV.Value in
    let cachedValues = handle constructDCT KV key (get `s ()) with hashedFetch hash in
        if Utils.member KV.Value value cachedValues
        then value
        else match cachedValues with
             | (cachedValue::_) => cachedValue
             | [] => let (newValue, deps) = track task in
                     let handle `b with hashedFetch hash in
                         recordDCT `s `b KV key newValue (List.map fst deps);
                         newValue
             end)
