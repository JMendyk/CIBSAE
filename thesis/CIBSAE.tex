% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk i rodzaj (lic/inz/mgr) pracy, oraz czy na
% drugiej stronie pracy ma byc skladany wzor oswiadczenia o autorskim wykonaniu.
\documentclass[shortabstract]{iithesis}

\usepackage[utf8]{inputenc}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\polishtitle    {Kwalifikacja i implementacja\fmlinebreak systemów kompilacji z użyciem\fmlinebreak efektów algebraicznych}
\englishtitle   {Categorization and implementation of Build Systems using algebraic effects}
\polishabstract {\ldots}
\englishabstract{\ldots}
% w pracach wielu autorow nazwiska mozna oddzielic poleceniem \and
\author         {Jakub Mendyk}
% w przypadku kilku promotorow, lub koniecznosci podania ich afiliacji, linie
% w ponizszym poleceniu mozna zlamac poleceniem \fmlinebreak
\advisor        {dr Filip Sieczkowski}
\date          {4 września 2020}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
\transcriptnum {301111}                     % Numer indeksu
\advisorgen    {dr. Filipa Sieczkowskiego} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
%\usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
\usepackage{cite}
\usepackage{amsmath, amsfonts}
\usepackage{stmaryrd} % double brackets
\usepackage{listings}
%
%%%%% WŁASNE DEFINICJE I POLECENIA
%
%\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
%\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
%\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
%\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
%\renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%

\begin{document}

%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY

\chapter{Wprowadzenie}

\section{Problemy z efektami ubocznymi}

Programy komputerowe, dzięki możliwości interakcji z zewnętrznymi zasobami -- takimi jak nośniki pamięci, sieci komputerowe czy użytkownicy oprogramowania -- mogą robić istotnie więcej niż tylko zadane wcześniej obliczenia. W ten sposób przebieg programu i jego końcowy wynik staje się jednak zależny od tegoż świata zewnętrznego, a sam program nie tylko serią czystych obliczeń ale także towarzyszących im efektów ubocznych.

Efekty uboczne powodują jednak, że rozumowanie i wnioskowanie o sposobie oraz prawidłowości działania programów staje się znacznie trudniejsze, a w konsekwencji ogranicza ich modularność i prowadzi do częstszych pomyłek ze strony autorów. Chcąc tego uniknąć, dąży się do wydzielania w programie jak największej części, która składa się z czystych obliczeń. Jednak to, czy jakiś moduł oprogramowania wykonuje obliczenia z efektami ubocznymi nie koniecznie jest jasne i często musimy zaufać autorowi, że w istocie tak jest.

\section{Radzenie sobie z efektami ubocznymi}

Jednym z rozwiązań tego problemu, jest zawarcie informacji o posiadaniu efektów ubocznych w systemie typów. Możemy wykorzystać wtedy dedukcji i weryfikacji typów do automatycznej identyfikacji modułów zawierających efekty uboczne. Programista może łatwo wyczytać z sygnatury funkcji, że w czasiej jej działania występują efekty uboczne. Znanym przykładem takiego rozwiązania jest wykorzystanie monad w języku programowania Haskell. Niestety, jednoczesne użytkowanie dwóch niezależnych zasób reprezentowanych przez różne monady nie jest możliwe i wymaga dodatkowych struktur, takich jak transformery monad, które niosą ze sobą dodatkowe problemy. Problem modularności został jedynie przesunięty w inny obszar.

Nowym, konkurencyjnym podejściem do ujarzmienia efektów ubocznych przez wykorzystanie systemu typów są efekty algebraiczne z uchwytami. Powierzchownie, zdają się być podobne do konstrukcji obsługi wyjątków w językach programowania lub wywołań systemowych w systemach operacyjnych. Dzięki rozdziałowi między definicjami operacji związanych z efektami ubocznymi, a ich sematyką oraz interesującemu zastosowaniu kontynuacji, dają łatwość myślenia i wnioskowania o programach ich używających. Ponadto, w przeciwieństwie do monad, można je bezproblemowo składać.

\section{Systemy kompilacji}

Przykładami programów, których głównym zadaniem jest interakcja z zewnętrznymi zasobami są systemy kompilacji, w których użytkownik opisuje proces wytwarzania wyniku jako zbiór wzajemnie-zależnych zadań, wraz z informacją jak zadania są wykonywane w oparciu o wyniki innych podzadań, a system jest odpowiedzialny za poprawne uporządkowanie i wykonanie otrzymanych zadań. W czasie działania, system agreguje wyniki obliczeń (np. na dysku lub w pamięci) i decyduje, która zadania powinny być obliczone ponownie -- np. system Make lub popularne narzędzie biurowe Excel.

W publikacjach pod tytułem ,,Build systems {\`a} la carte'' \cite{mokhov2018build} \cite{mokhov2020build}, autorzy przedstawiają sposób klasyfikacji systemów kompilacji w oparciu o to jak determinują one kolejność w jakiej zadania zostaną obliczone oraz jak wyznaczają, które z zadań wymagają ponownego obliczenia. Uzyskana klasyfikacja prowadzi autorów do skonstruowania platformy umożliwającej konstrukcję systemów kompilacji o oczekiwanych właściwościach. Platforma ta okazuje się być łatwa w implementacji w języku Haskell, a klasy typów Applicative oraz Functor odpowiadać mocy języka opisywnia zależności między zadaniami do obliczenia.

\section{O tej pracy}

Celem tej pracy jest zapoznanie czytelnika, który miał dotychczas kontakt z językiem Haskell oraz podstawami języków funkcyjny, z nowatorskim rozwiązaniem jakim są efekty algebraiczne oraz zademonstrowanie -- idąc śladami Makhov i innych \cite{mokhov2018build} -- implementacji systemów kompilacji z wykorzystaniem efektów algebraicznych i uchwytów w języku programowania Helium. Jak się okazuje, wykorzystanie tych narzędzi daje schludną implementację ale także prowadzi do problemów w implementacji systemów z topologicznym planistą.





\chapter{O efektach algebraicznych teoretycznie}

Wprowadzimy notację służącą opisowi prostych obliczeń, która pomoże i doprowadzi nas do zrozumienia czym są efekty algebraiczne i uchwyty. Następnie przyjrzymy się, jak możemy zapisać popularne przykłady efektów ubocznych używając naszej notacji. Na koniec, czytelnikowi zostaną polecone dobre zasoby, dzięki którym będzie mógł jeszcze bardziej zagłębić się w teorii efektów algebraicznych oraz ścieżce prowadzącej do skonstruowania stojącej za nimi teorii.

\section{Notacja}

\newcommand{\return}[1]{\mathbf{return}\ #1}
\newcommand{\op}[3]{op_{#1}(#2, #3)}
\newcommand{\handle}[2]{\mathbf{handle}\ #1\ \mathbf{with}\ #2}
\newcommand{\hcase}[3]{#1\ #2\ \Rightarrow\ #3}
\newcommand{\fun}[2]{\lambda #1.\ #2}
\newcommand{\eval}[1]{\llbracket\, #1\, \rrbracket}
\newcommand{\cond}[3]{\mathbf{if}\ #1\ \mathbf{then}\ #2\ \mathbf{else}\ #3}



Będziemy rozważać obliczenia nad wartościami boolowskimi, liczbami całkowitymi wraz z ich równością oraz podstawowymi działaniami arytmetycznymi i funkcjami ich używającymi. Ponadto nasz model składać się będzie także z wyrażeń:
\begin{itemize}
\item \(\return{v}\) -- gdzie \(v\) jest wyrażeniem arytmetycznym,
\item \(\cond{v_1 = v_2}{e_t}{e_f}\) -- wyrażenie warunkowe, gdzie \(v_1 = v_2\) jest pytaniem o równość wartości dwóch wyrażeń arytmetycznych,
\item abstrakcyjnych operacji oznaczanych \(\{op_i\}_{i \in I}\) -- powodujących wystąpienie efektów ubocznych -- których działanie nie jest nam znane, zaś ich sygnatury to \(op_i: \mathbb{Z} \rightarrow (\mathbb{Z} \rightarrow \mathbb{Z}) \rightarrow \mathbb{Z}\). Wyrażenie~\(\op{i}{n}{\kappa}\) opisuje operację z argumentami \(n\) oraz dalszą częścią obliczenia \(\kappa\) parametryzowaną wynikiem operacji, które \textit{może (nie musi)} zostać wykonane po jej wystąpieniu,
\item uchwytów, czyli wyrażeń postaci \(\handle{e}{\{\ \hcase{op_i}{n\ \kappa}{h_i}\ \}_{i \in I}}\) które definiują działanie (dotychczas abstrakcyjnych) efektów ubocznych. 

\end{itemize}

Przykładowymi obliczeniami w naszej notacji są więc:
\begin{equation*}
\begin{gathered}
  \return{0},\ \return{2 + 2},\ \op{1}{2}{\fun{x}{\return{x + 1}}} \\
  \handle{\op{1}{2}{\fun{x}{\return{x + 1}}}}{\{\ \hcase{op_1}{n\ \kappa}{\kappa\ (2 \cdot n)} \ \}}
\end{gathered}
\end{equation*}

Dla czytelności, pisząc w uchwycie zbiór który nie przebiega wszystkich operacji, przyjmujemy że uchwyt nie definiuje działania operacji; równoważnie, zbiór wzbogacamy o element: \(\hcase{op_i}{n\ \kappa}{op_i(n, \kappa)}\).

Obliczanie wartości wyrażenia przebiega następująco:
\begin{itemize}
\item \(\eval{\return v} = v\) -- wartością \(\mathbf{return}\) jest wartość wyrażenia arytmetycznego,
\item \(\eval{(\fun{x}{e})\ y} = \eval{e \left[x / \eval{y}\right]}\) -- aplikacja argumentu do funkcji,
\item
  \(\begin{aligned}[t]
    \eval{\cond{v_1 = v_2}{e_t}{e_f}} = \left\{\begin{matrix}
    \eval{e_t} & \text{gdy }\eval{v_1} = \eval{v_2} \\ 
    \eval{e_f} & \text{wpp}
    \end{matrix}\right.
  \end{aligned}\)
%% \item \(\eval{\op{i}{a}{f}} = \op{i}{a}{f}\) -- obliczenie z efektem ubocznym nie może poczynić postępu póki nie ma określonego działania,
\item \(\eval{\handle{\return v}{H}} = \eval{\return v}\) -- uchwyt nie wpływa na wartość obliczenia, które nie zawiera efektów ubocznych,
\item \(\eval{\handle{\op{i}{a}{f}}{\{\ \hcase{op_i}{n\ \kappa}{h_i} \ \}}} =
  \eval{\handle{h_i \left[n / \eval{a},\, \kappa / f\right]}{\{\ \hcase{op_i}{n\ \kappa}{h_i} \ \}}} \), przy czym \(h_i\) nie ma wystąpień \(op_i\).
  
\end{itemize}

Zobaczmy jak zatem wygląda obliczenie ostatniego z powyższych przykładów:
\begin{align*}
  \eval{\handle{\op{1}{2}{\fun{x}{\return{x + 1}}}}{\{\ \hcase{op_1}{n\ \kappa}{\kappa\ (2 \cdot n)} \ \}}} &= \\
  \eval{\handle{(\fun{x}{\return{x+1}}) (2 \cdot 2)}{\{\ \hcase{op_1}{n\ \kappa}{\kappa\ (2 \cdot n)} \ \}}} &= \\
  \eval{\handle{\return{4+1}}{\{\ \hcase{op_1}{n\ \kappa}{\kappa\ (2 \cdot n)} \ \}}} &= \\
  \eval{\return{4 + 1}} &= 5
\end{align*}


\section{Efekty i równania}

Do tego momentu, nie przyjmowaliśmy żadnych założeń na temat operacji powodujących efekty uboczne. Uchwyty mogły w związku z tym działać w sposób całkowicie dowolny. Ograniczymy się w tej dowolności i nałożymy warunki na uchwyty wybranych operacji. Przykładowo, ustalmy że dla operacji \(op_r\), uchwyty muszą być takie aby następujący warunek był spełniony:
\begin{align*}
  \forall n\ \forall e.\ \eval{\handle{op_r(n, \fun{x}{e})}{H}} = n
\end{align*}

\pagebreak

Zauważmy, że istnieje tylko jeden naturalny uchwyt spełniający tej warunek, jest nim \(H = \{\ \hcase{op_r}{n\ \kappa}{n} \ \}\). Co więcej, jego działanie łudząco przypomina konstrukcję wyjątków w popularnych językach programowania:

\begin{lstlisting}
  try {
    raise 5;
    // ...
  } catch (int n) {
    return n;
  }
\end{lstlisting}

Podobieństwo to jest w pełni zamierzone. Okazuje się że nasz mały język z jednym równaniem ma już moc wystarczającą do opisu konstrukcji, która w większości języków nie może zaistnieć z woli programisty, a zamiast tego musi być dostarczona przez twórcę języka.

Rozważmy kolejny przykład. Dla poprawienia czytelności, operacje powodujące efekty będą miały nazwy \(get\) oraz \(put\). Spróbujemy wyrazić działanie tych dwóch operacji by otrzymać modyfikowalną komórkę pamięci. Ustalmy też bardziej naturalny sygnatury operacji -- \(get: U \rightarrow \mathbb{Z}\), \(put: \mathbb{Z} \rightarrow U\). Gdzie \(U\) jest nowym typem -- jednostką -- zamieszkałym przez pojedyńczą wartość \(u\). Zastanówmy się jakie warunki takie operacje powinny spełniać:

\begin{itemize}
\item \(\forall e.\ \eval{get(u, \fun{\_}{get(u, \fun{x}{e})})} = \eval{get(u, \fun{x}{e}}\)

  kolejne odczyty z komórki bez jej modyfikowania dają takie same wyniki,
\item \(\forall e.\ \eval{get(u, \fun{n}{put(n, \fun{u}{e})})} = \eval{e}\)

  umieszczenie w komórce wartości która już tam się znajduje nie wpływa na wynik obliczenia,
\item \(\forall n.\ \forall f.\ \eval{put(n, \fun{u}{get(u, \fun{x}{f\ x})})} = \eval{f\ n}\)

  obliczenie które odczytuje wartość z komórki daje taki sam wyniki, jak gdyby miało wartość komórki podaną wprost jako argument,
\item \(\forall n_1.\ \forall n_2.\ \forall e.\ \eval{put(n_1, \fun{u}{put(n_2, \fun{u}{e})})} = \eval{put(n_2, \fun{u}{e})}\)

  komórka pamięta jedynie najnowszą włożoną do niej wartość.
\end{itemize}

Zauważmy, że choć nakładamy warunki na zewnętrzne skutki działania operacji \(get\) oraz \(put\), to w żaden sposób nie ograniczyliśmy swobody autora w implementacji uchwytów dla tych operacji.

%% \begin{align*}
%%   \forall e.\ \eval{get(u, \fun{\_}{get(u, \fun{x}{e})})} &= \eval{get(u, \fun{x}{e}} \\
%%   \forall e.\ \eval{get(u, \fun{n}{put(n, \fun{u}{e})})} &= \eval{e} \\
%%   \forall n.\ \forall f.\ \eval{put(n, \fun{u}{get(u, \fun{x}{f\ x})})} &= \eval{f\ n} \\
%%   \forall n_1.\ \forall n_2.\ \forall e.\ \eval{put(n_1, \fun{u}{put(n_2, \fun{u}{e})})} &= \eval{put(n_2, \fun{u}{e})}
%% \end{align*}

%% Pierwsze równanie wymusza, by kolejne odczyty z komórki bez jej modyfikowania dawały takie same wyniki, zaś drugie że umieszczenie w komórce wartości która już tam się znajduje nie wpływa na wynik obliczenia. Trzecie równanie daje gwarancję, że obliczenie które odczytuje wartość z komórki daje taki sam wyniki, jak gdyby miało wartość komórki podaną wprost jako argument. Czwarte równanie wymusza, by komórka pamiętała jedynie najnowszą włożoną do niej wartość.

\cite{bauer2018algebraic}

\chapter{O systemach kompilacji (i ich klasyfikacji)}

\chapter{Efekty algebraiczne i uchwyty w~praktyce}

\chapter{Systemy kompilacji z użyciem efektów algebraicznych i~uchwytów}

\chapter{Podsumowanie i wnioski}

\ldots

%%%%% BIBLIOGRAFIA

\nocite{biernacki2017handle}
\nocite{biernacki2019abstracting}
\nocite{biernacki2019binders}
\nocite{pretnar2015introduction}

\bibliographystyle{abbrv}
\bibliography{bibliography}

\end{document}
