import String
import Set
import List

import Logger
import Spreadsheet
import State
import Store

import Utils

open Logger
open Spreadsheet
open State
open Store

open Utils

let printInt' x = printStr (stringOfInt x)
let printIntList xs =
    let rec printWithSep xs sep = match xs with
                              | [] => ()
                              | [x] => printInt' x
                              | (x::xs) => printInt' x; printStr ", "; printWithSep xs sep
                              end
    in
    printStr "[";
    printWithSep xs ",";
    printStr "]"

type KeyOrder = sig
  type this: Type
  val compare: this -> this -> Ord
  val toString: this -> String
end

let member (module T: KeyOrder) (a: T.this) (xs: List T.this) =
    let rec member (xs: List T.this) =
        match xs with
        | [] => False
        | (x::xs) => match T.compare a x with
                     | EQ => True
                     |  _ => member xs
                     end
        end
    in member xs

(* Chcielibyśmy mieć coś takiego: *)

(* let _ = *)
(*     handle buildA task *)
(*     with schedulerAndRebuilder *)

(* albo na przykład: *)

(* let _ = *)
(*     handle *)
(*         handle buildB task *)
(*         with scheduler *)
(*     with rebuilder *)



signature BuildEff (K: Type) (V: Type) =
| fetch : K => V

data TaskType (K: Type) (V: Type) = Task of ({`a: BuildEff K V} -> Unit ->[`a] V)
let unTask (Task t) = t

type Tasks (K: Type) (V: Type) = (K -> Option (TaskType K V))

(* Zmodyfikowany przykład z Carte: *)

let sprsh1_B1 () = fetch (C "A1") + fetch (C "A2") + fetch C3
let sprsh1_B2 () = (fetch B1 + fetch B1) + fetch (C "A1")
let sprsh1_C3 () = 3 * fetch (C "A1") + fetch (C "A2")

let sprsh1 (cid: SpreadsheetCell) =
    match cid with
    | B1 => Some $ Task sprsh1_B1
    | B2 => Some $ Task sprsh1_B2
    | C3 => Some $ Task sprsh1_C3
    | _ => None
    end

let initState = fn key => match key with
                          | (C c) => if String.equal c "A1" then 10 else 20
                          | _ => 20
                          end


let withBusy {i v: Type} (module T: KeyOrder) (`a: Store.StoreEff i T.this v) (key: T.this) (tasks: Tasks T.this v) =
    let handle with indentLogHandler in
    let rec busyHandler =
        handler
        | fetch k => build k; resume (getValue k)
        end
        and build (key: T.this) =
        entry ();
        logln (T.toString key ++ "\n");
        match tasks key with
        | None => ()
        | Some (Task task) =>
               putValue key (handle task () with busyHandler)
        end;
        exit ()
    in
    logln ("Building " ++ T.toString key ++ " with busy\n");
    build key

(* Chyba brak struktury podobnej do Applicative/statycznych zależności.
   Możemy jednak śledzić/track obliczane taski potomne początkowego: *)

let track (key: SpreadsheetCell) (tasks: Tasks SpreadsheetCell Int) =
    let handle with runState [] in
    let rec hTrack =
        handler
        (* Not really working as we would like to since it's tracking all (including transitive/offspring) dependencies*)
        | fetch k => modifyState (fn s => k::s); ignore (deps k); resume (getValue k)
        end
        and deps key =
        match tasks key with
        | None => ()
        | Some (Task task) =>
               let newValue = handle task () with hTrack in
               putValue (key, newValue)
        end
    in deps key

(* Oblicz zadanie bez modyfikowania stanu (Carte 3.6) *)
let compute task =
    handle task () with
    | fetch k => getValue k
    end


let withSuspending {i v: Type} (module T: KeyOrder) (`a: Store.StoreEff i T.this v) (key: T.this) (tasks: Tasks T.this v) =
    let type ST = Set T in
    open T in
    let handle with indentLogHandler in
    let handle with evalState ST.empty in
        let rec suspendingHandler =
            handler
            | fetch k => build k; resume (getValue k)
            end
            and build key =
            entry ();
            logln (T.toString key ++ " ");
            let done = get () in
            match (tasks key, ST.mem key done) with
            | (Some (Task task), False) =>
               log "computing...\n";
               let value = getValue key in
               (* TODO: Rebuilder *)
               let newValue = handle task () with suspendingHandler
               in put (ST.add key done);
                  putValue key newValue
             | (None, _) => log "(i)\n"
             | (Some _, True) => log "already computed\n"
             end;
             exit ()
        in
        log ("Building " ++ T.toString key ++ " with suspending\n");
        build key

let withRestarting {i v: Type} (module T: KeyOrder) (`a: Store.StoreEff (Pair i (List T.this)) T.this v) (key: T.this) (tasks: Tasks T.this v) =
    let type ST = Set T in
    let handle with indentLogHandler in
    let oldChain = snd $ getInfo () in
    let newChain = oldChain @ (if member T key oldChain then [] else [key]) in
    let handle `q with evalState newChain in
    (* let handle `q with runState [C "A1", C "A2", C3, B1, B2] in *)
    let handle `s with evalState ST.empty in
        let rec neq dep x = match T.compare x dep with
                              | EQ => False
                              | _ => True
                              end
        and qInsert dep = match get `q () with
                          | [] => runtimeError "empty work queue\n"
                          | (curr::rest) => let after = (dep :: filter (neq dep) rest) @ [curr] in
                                            put `q after
                          end
        and restartingHandler =
            handler
            (* TODO: Rebuilder *)
            | fetch k => (* logln ("Fetching: " ++ T.toString k ++ "\n"); *)
                         if (ST.mem k (get `s ())) then
                            resume (getValue k)
                         else match get `q () with
                              | [] => runtimeError "fetch from empty work queue\n"
                              | (curr::rest) => log (T.toString curr ++ " will be restarted\n"); qInsert k; loop ()
                              end
            | return x => match get `q () with
                          | [] => runtimeError "return from empty work queue\n"
                          | (curr::rest) => logln ("Finished " ++ T.toString curr ++ "\n");
                                            put `s (ST.add curr (get `s ()));
                                            putValue curr x;
                                            loop ()
                          end
            end
        and loop () =
            match get `q () with
            | [] => []
            | (key::keys) => match (tasks key, ST.mem key (get `s ())) with
                             | (Some (Task task), False) =>
                               log ("computing " ++ T.toString key ++ "\n");
                               let result = handle task () with restartingHandler in
                               result
                             | (None, _) =>
                                            log ("input " ++ T.toString key ++ "\n");
                                            put `s (ST.add key (get `s ()));
                                            put `q keys;
                                            key :: loop ()
                             | (Some _, True) =>
                                                 log ("computed " ++ T.toString key ++ "\n");
                                                 put `q keys;
                                                 key :: loop ()
                             end
            end
        in
        log ("Building " ++ T.toString key ++ " with restarting\n");
        let resultChain = loop () in
        modifyInfo (fn (i, _) => (i, resultChain))

let _ =
    let funHandler = funStoreHandler CellOrder in
    let s = FunStore ((), []) initState in
    ignore (handle `s in
        printIntList (List.map (getValue `s) [B1, B2, C3]); printStr "\n"
    with funHandler s);
    let (_, s') =
        handle
            (* withBusy CellOrder B2 sprsh1 *)
            withSuspending CellOrder B2 sprsh1
            (* withRestarting CellOrder B2 sprsh1 *)
        with funStoreHandler CellOrder s in
    ignore (handle `s in
        printIntList (List.map (getValue `s) [B1, B2, C3]); printStr "\n"
    with funHandler s');
    let (_, s'') =
        handle
            (* withBusy CellOrder B2 sprsh1 *)
            withSuspending CellOrder B2 sprsh1
            (* withRestarting CellOrder B2 sprsh1 *)
        with funStoreHandler CellOrder s' in
    ignore (handle `s in
        printIntList (List.map (getValue `s) [B1, B2, C3]); printStr "\n"
    with funHandler s'')
