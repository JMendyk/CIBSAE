import String
import Set

import Spreadsheet
import State
import Store

open Spreadsheet
open State
open Store

let printInt' x = printStr (stringOfInt x)
let printIntList xs =
    let rec printWithSep xs sep = match xs with
                              | [] => ()
                              | [x] => printInt' x
                              | (x::xs) => printInt' x; printStr ", "; printWithSep xs sep
                              end
    in
    printStr "[";
    printWithSep xs ",";
    printStr "]"

let ( $ ) f x = f x

type SC = Set CellOrder
(* Chcielibyśmy mieć coś takiego: *)

(* let _ = *)
(*     handle buildA task *)
(*     with schedulerAndRebuilder *)

(* albo na przykład: *)

(* let _ = *)
(*     handle *)
(*         handle buildB task *)
(*         with scheduler *)
(*     with rebuilder *)



signature BuildEff (K: Type) (V: Type) =
| fetch : K => V

data TaskType (K: Type) (V: Type) = Task of ({`a: BuildEff K V} -> Unit ->[`a] V)
let unTask (Task t) = t

type Tasks (K: Type) (V: Type) = (K -> Option (TaskType K V))

(* Zmodyfikowany przykład z Carte: *)

let sprsh1_B1 () = fetch (C "A1") + fetch (C "A2") + fetch C3
let sprsh1_B2 () = (fetch B1 + fetch B1) + fetch (C "A1")
let sprsh1_C3 () = 3 * fetch (C "A1") + fetch (C "A2")

let sprsh1 (cid: SpreadsheetCell) =
    match cid with
    | B1 => Some $ Task sprsh1_B1
    | B2 => Some $ Task sprsh1_B2
    | C3 => Some $ Task sprsh1_C3
    | _ => None
    end

let initState = fn key => match key with
                          | (C c) => if String.equal c "A1" then 10 else 20
                          | _ => 20
                          end

let cellToString x = match x with
                     | B1 => "B1"
                     | B2 => "B2"
                     | C3 => "C3"
                     | (C c) => c
                     end

let printCellList xs =
    let rec printWithSep xs sep = match xs with
                              | [] => ()
                              | [x] => printStr (cellToString x)
                              | (x::xs) => printStr (cellToString x); printStr ", "; printWithSep xs sep
                              end
    in
    printStr "[";
    printWithSep xs ",";
    printStr "]"

let withBusy (key: SpreadsheetCell) tasks =
    let rec busyHandler =
        handler
        | fetch k => build k; resume (getValue k)
        end
        and build key =
        printStr (String.repeat (2 * getInfo ()) ' ');
        printStr (cellToString key ++ "\n");
        incInfo ();
        match tasks key with
        | None => ()
        | Some (Task task) =>
               printStr (String.repeat (2 * getInfo ()) ' ');
               printStr ("Computing " ++ cellToString key ++ "...\n");
               let ret = handle task () with busyHandler
               in putValue (key, ret)
        end;
        decInfo ()
    in
    printStr ("Building " ++ cellToString key ++ " with busy\n");
    build key

(* Chyba brak struktury podobnej do Applicative/statycznych zależności.
   Możemy jednak śledzić/track obliczane taski potomne początkowego: *)

let track (key: SpreadsheetCell) (tasks: Tasks SpreadsheetCell Int) =
    let rec deps key =
        match tasks key with
        | None => getValue key
        | Some (Task task) =>
               let ret = handle task () with
               | fetch k => modifyState (fn s => k::s); resume (deps k)
               end in putValue (key, ret); ret
        end
    in deps key

(* Oblicz zadanie bez modyfikowania stanu (Carte 3.6) *)
let compute task =
    handle task () with
    | fetch k => getValue k
    end

let rec mem n xs = match xs with
                   | [] => False
                   | (x::xs) => match CellOrder.compare n x with
                                | EQ => True
                                | _ => mem n xs
                                end
                   end

let withSuspending (key: SpreadsheetCell) tasks =
    handle
        let rec suspendingHandler =
            handler
            | fetch k => build k; resume (getValue k)
            end
            and build key =
            printStr (String.repeat (2 * getInfo ()) ' ');
            printStr (cellToString key ++ "\n");
            incInfo ();
            let done = get () in 
            match (tasks key, SC.mem key done) with
            | (Some (Task task), False) =>
               printStr (String.repeat (2 * getInfo ()) ' ');
               printStr ("Computing " ++ cellToString key ++ "...\n");
               let value = getValue key in
               (* TODO: Rebuilder *)
               let newValue = handle task () with suspendingHandler
               in put (SC.add key done);
                  putValue (key, newValue)
             | _ => ()
             end;
             decInfo ()
        in
        printStr ("Building " ++ cellToString key ++ " with suspending\n");
        build key
    with runState SC.empty

let _ =
    let s = initState in
    printIntList [s B1, s B2, s C3]; printStr "\n";
    let (_, (_, s)) = 
    handle
        (* withBusy B2 sprsh1 *)
        withSuspending B2 sprsh1
    with funInfoHandler sComp 0 initState in
    printIntList [s B1, s B2, s C3]; printStr "\n";
    ()