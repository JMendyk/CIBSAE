import String
import Set

import Spreadsheet
import State
import Store

open Spreadsheet
open State
open Store

let printInt' x = printStr (stringOfInt x)
let printIntList xs =
    let rec printWithSep xs sep = match xs with
                              | [] => ()
                              | [x] => printInt' x
                              | (x::xs) => printInt' x; printStr ", "; printWithSep xs sep
                              end
    in
    printStr "[";
    printWithSep xs ",";
    printStr "]"

let ( $ ) f x = f x

type SC = Set CellOrder
(* Chcielibyśmy mieć coś takiego: *)

(* let _ = *)
(*     handle buildA task *)
(*     with schedulerAndRebuilder *)

(* albo na przykład: *)

(* let _ = *)
(*     handle *)
(*         handle buildB task *)
(*         with scheduler *)
(*     with rebuilder *)



signature BuildEff (K: Type) (V: Type) =
| fetch : K => V

data TaskType (K: Type) (V: Type) = Task of ({`a: BuildEff K V} -> Unit ->[`a] V)
let unTask (Task t) = t

type Tasks (K: Type) (V: Type) = (K -> Option (TaskType K V))

(* Zmodyfikowany przykład z Carte: *)

let sprsh1_B1 () = fetch (C "A1") + fetch (C "A2") + fetch C3
let sprsh1_B2 () = (fetch B1 + fetch B1) + fetch (C "A1")
let sprsh1_C3 () = 3 * fetch (C "A1") + fetch (C "A2")

let sprsh1 (cid: SpreadsheetCell) =
    match cid with
    | B1 => Some $ Task sprsh1_B1
    | B2 => Some $ Task sprsh1_B2
    | C3 => Some $ Task sprsh1_C3
    | _ => None
    end

(* let rec busy tasks lookup = *)
(*     handler *)
(*     | fetch k => fn xs => match tasks k with *)
(*                  | None => resume (xs k) xs *)
(*                  | Some (Task task) => *)
(*                    let v = handle task () with busy tasks xs in *)
(*                    let lookup = fn k1 => if sComp k1 k then v else xs k1 in *)
(*                    resume v lookup *)
(*                  end *)
(*     | return x => fn _ => x *)
(*     | finally f => f lookup *)
(*     end *)


(* let rec withBusy = fn (f: TaskType SpreadsheetCell Int) (tasks: Tasks SpreadsheetCell Int) (lookup: SpreadsheetCell -> Int) => *)
(*     handle (unTask f) () with *)
(*     | fetch k => match tasks k with *)
(*                  | None => resume (lookup k) *)
(*                  | Some task => *)
(*                    let v = withBusy task tasks lookup in *)
(*                    resume v *)
(*                  end *)
(*     end *)

(* let withBusy1 f (tasks: Tasks SpreadsheetCell Int) (lookup: SpreadsheetCell -> Int) = *)
(*     let rec bound f1 = handle f1 () with *)
(*     | fetch k => match tasks k with *)
(*                  | None => resume (getValue k) *)
(*                  | Some (Task task) => *)
(*                    let v = 10 in *)
(*                    putValue (k, v); *)
(*                    resume v *)
(*                  end *)
(*     end in *)
(*     handle bound f with funInfoHandler sComp 0 lookup *)

(* let neww key (tasks: Tasks SpreadsheetCell Int) (lookup: SpreadsheetCell -> Int) = *)
(*     match tasks key with *)
(*     | None => lookup key *)
(*     | Some (Task task) => withBusy1 task tasks lookup *)
(*     end *)
    

let initState = fn key => match key with
                          | (C c) => if String.equal c "A1" then 10 else 20
                          | _ => 20
                          end

(* let build tasks key store = *)
(*     match tasks key with *)
(*     | None => store key *)
(*     | Some (Task task) => handle task () with busy tasks store *)
(*     end *)

(* let _ = *)
(*     match sprsh1 B1 with *)
(*     | Some t => printInt (withBusy t sprsh1 initState) *)
(*     | None => printStr ":(" *)
(*     end *)
(*     printInt $ build sprsh1 B1 initState; *)
(*     (\* ignore sprsh1; *\) *)
(*     (\* build sprsh1; *\) *)
(*     (\* printInt (build sprsh1 B1 (initState (C "A1"))); *\) *)
(*     () *)

let cellToString x = match x with
                     | B1 => "B1"
                     | B2 => "B2"
                     | C3 => "C3"
                     | (C c) => c
                     end

let printCellList xs =
    let rec printWithSep xs sep = match xs with
                              | [] => ()
                              | [x] => printStr (cellToString x)
                              | (x::xs) => printStr (cellToString x); printStr ", "; printWithSep xs sep
                              end
    in
    printStr "[";
    printWithSep xs ",";
    printStr "]"

let rec repeatStr n s = if n <= 0 then "" else s ++ repeatStr (n-1) s

let withBusy (key: SpreadsheetCell) tasks =
    let rec build key =
        printStr (repeatStr (2 * getInfo ()) " ");
        printStr (cellToString key ++ "\n");
        incInfo ();
        match tasks key with
        | None => ()
        | Some (Task task) =>
               printStr (repeatStr (2 * getInfo ()) " ");
               printStr ("Computing " ++ cellToString key ++ "...\n");
               let ret = handle task () with
                         | fetch k => resume (build k)
                         end
               in putValue (key, ret); ()
        end;
        decInfo ();
        getValue key
    in
    printStr ("Building " ++ cellToString key ++ " with busy\n");
    build key

(* Chyba brak struktury podobnej do Applicative/statycznych zależności.
   Możemy jednak śledzić/track obliczane taski potomne początkowego: *)

let track (key: SpreadsheetCell) (tasks: Tasks SpreadsheetCell Int) =
    let rec deps key =
        match tasks key with
        | None => getValue key
        | Some (Task task) =>
               let ret = handle task () with
               | fetch k => modifyState (fn s => k::s); resume (deps k)
               end in putValue (key, ret); ret
        end
    in deps key

(* Oblicz zadanie bez modyfikowania stanu (Carte 3.6) *)
let compute task =
    handle task () with
    | fetch k => getValue k
    end

let rec mem n xs = match xs with
                   | [] => False
                   | (x::xs) => match CellOrder.compare n x with
                                | EQ => True
                                | _ => mem n xs
                                end
                   end

let withSuspending (key: SpreadsheetCell) tasks =
    handle
        let rec build key =
            printStr (repeatStr (2 * getInfo ()) " ");
            printStr (cellToString key ++ "\n");
            incInfo ();
            let done = get () in 
            match (tasks key, SC.mem key done) with
            | (Some (Task task), False) =>
               printStr (repeatStr (2 * getInfo ()) " ");
               printStr ("Computing " ++ cellToString key ++ "...\n");
               let value = getValue key in
               (* TODO: Rebuilder *)
               let ret = handle task () with
                         | fetch k => resume (build k)
                         end
               in put (SC.add key done);
                  putValue (key, ret);
                  ()
             | _ => ()
             end;
             decInfo ();
             getValue key
        in
        printStr ("Building " ++ cellToString key ++ " with suspending\n");
        build key
    with runState SC.empty

let _ =
    (* let (s, _) = handle (handle withDependencies B2 sprsh1 with funInfoHandler sComp 0 initState) with runState [] in printCellList s; *)
    (* printStr "\n"; *)
    (* printInt (handle withBusy B2 sprsh1 with funInfoHandler sComp 0 initState); *)
    let s = initState in
    printIntList [s B1, s B2, s C3]; printStr "\n";
    let (_, (_, s)) = 
    handle
        (* withBusy B2 sprsh1 *)
        withSuspending B2 sprsh1
    with funInfoHandler sComp 0 initState in
    printIntList [s B1, s B2, s C3]; printStr "\n";
    ()