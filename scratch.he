import Common
import Store
import Schedulers
import Spreadsheet

import String
import List

open Common
open Store
open Schedulers
open Spreadsheet

let printInt' x = printStr (stringOfInt x)
let printIntList xs =
    let rec printWithSep xs sep = match xs with
                              | [] => ()
                              | [x] => printInt' x
                              | (x::xs) => printInt' x; printStr ", "; printWithSep xs sep
                              end
    in
    printStr "[";
    printWithSep xs ",";
    printStr "]"

(* Chcielibyśmy mieć coś takiego: *)

(* let _ = *)
(*     handle buildA task *)
(*     with schedulerAndRebuilder *)

(* albo na przykład: *)

(* let _ = *)
(*     handle *)
(*         handle buildB task *)
(*         with scheduler *)
(*     with rebuilder *)

let ( $ ) f x = f x

(* Zmodyfikowany przykład z Carte: *)

let sprsh1_B1 () = fetch (C "A1") + fetch (C "A2") + fetch C3
let sprsh1_B2 () = (fetch B1 + fetch B1) + fetch (C "A1")
let sprsh1_C3 () = 3 * fetch (C "A1") + fetch (C "A2")

let sprsh1 (cid: SpreadsheetCell) =
    match cid with
    | B1 => Some $ Task sprsh1_B1
    | B2 => Some $ Task sprsh1_B2
    | C3 => Some $ Task sprsh1_C3
    | _ => None
    end

let initState = fn key => match key with
                          | (C c) => if String.equal c "A1" then 10 else 20
                          | _ => 20
                          end

(* Chyba brak struktury podobnej do Applicative/statycznych zależności.
   Możemy jednak śledzić/track obliczane taski potomne początkowego: *)

let track (key: SpreadsheetCell) (tasks: Tasks SpreadsheetCell Int) =
    let handle with runState [] in
    let rec hTrack =
        handler
        (* Not really working as we would like to since it's tracking all (including transitive/offspring) dependencies*)
        | fetch k => modifyState (fn s => k::s); ignore (deps k); resume (getValue k)
        end
        and deps key =
        match tasks key with
        | None => ()
        | Some (Task task) =>
               let newValue = handle task () with hTrack in
               putValue (key, newValue)
        end
    in deps key

(* Oblicz zadanie bez modyfikowania stanu (Carte 3.6) *)
let compute task =
    handle task () with
    | fetch k => getValue k
    end



let dumpStoreContents (module T: KeyOrder) keys s =
    ignore(handle `s in
        printIntList (List.map (getValue `s) keys); printStr "\n"
    with funStoreHandler T s)

let _ =
    let dump = dumpStoreContents CellOrder [B1, B2, C3] in
    let s = FunStore ((), []) initState in
    dump s;
    let (_, s') =
        handle
            (* withBusy CellOrder B2 sprsh1 *)
            withSuspending CellOrder B2 sprsh1
            (* withRestarting CellOrder B2 sprsh1 *)
        with funStoreHandler CellOrder s in
    dump s';
    let (_, s'') =
        handle
            (* withBusy CellOrder B2 sprsh1 *)
            withSuspending CellOrder B2 sprsh1
            (* withRestarting CellOrder B2 sprsh1 *)
        with funStoreHandler CellOrder s' in
    dump s''

