import String
import Set
import List

import Logger
import Spreadsheet
import State
import Store

import utils

open Logger
open Spreadsheet
open State
open Store

open utils

let printInt' x = printStr (stringOfInt x)
let printIntList xs =
    let rec printWithSep xs sep = match xs with
                              | [] => ()
                              | [x] => printInt' x
                              | (x::xs) => printInt' x; printStr ", "; printWithSep xs sep
                              end
    in
    printStr "[";
    printWithSep xs ",";
    printStr "]"

let ( $ ) f x = f x

type SC = Set CellOrder
(* Chcielibyśmy mieć coś takiego: *)

(* let _ = *)
(*     handle buildA task *)
(*     with schedulerAndRebuilder *)

(* albo na przykład: *)

(* let _ = *)
(*     handle *)
(*         handle buildB task *)
(*         with scheduler *)
(*     with rebuilder *)



signature BuildEff (K: Type) (V: Type) =
| fetch : K => V

data TaskType (K: Type) (V: Type) = Task of ({`a: BuildEff K V} -> Unit ->[`a] V)
let unTask (Task t) = t

type Tasks (K: Type) (V: Type) = (K -> Option (TaskType K V))

(* Zmodyfikowany przykład z Carte: *)

let sprsh1_B1 () = fetch (C "A1") + fetch (C "A2") + fetch C3
let sprsh1_B2 () = (fetch B1 + fetch B1) + fetch (C "A1")
let sprsh1_C3 () = 3 * fetch (C "A1") + fetch (C "A2")

let sprsh1 (cid: SpreadsheetCell) =
    match cid with
    | B1 => Some $ Task sprsh1_B1
    | B2 => Some $ Task sprsh1_B2
    | C3 => Some $ Task sprsh1_C3
    | _ => None
    end

let initState = fn key => match key with
                          | (C c) => if String.equal c "A1" then 10 else 20
                          | _ => 20
                          end


let withBusy (key: SpreadsheetCell) tasks =
    let handle with indentLogHandler in
    let rec busyHandler =
        handler
        | fetch k => build k; resume (getValue k)
        end
        and build key =
        entry ();
        logln (cellToString key ++ "\n");
        match tasks key with
        | None => ()
        | Some (Task task) =>
               putValue key (handle task () with busyHandler)
        end;
        exit ()
    in
    logln ("Building " ++ cellToString key ++ " with busy\n");
    build key

(* Chyba brak struktury podobnej do Applicative/statycznych zależności.
   Możemy jednak śledzić/track obliczane taski potomne początkowego: *)

let track (key: SpreadsheetCell) (tasks: Tasks SpreadsheetCell Int) =
    let handle with runState [] in
    let rec hTrack =
        handler
        (* Not really working as we would like to since it's tracking all (including transitive/offspring) dependencies*)
        | fetch k => modifyState (fn s => k::s); ignore (deps k); resume (getValue k)
        end
        and deps key =
        match tasks key with
        | None => ()
        | Some (Task task) =>
               let newValue = handle task () with hTrack in
               putValue (key, newValue)
        end
    in deps key

(* Oblicz zadanie bez modyfikowania stanu (Carte 3.6) *)
let compute task =
    handle task () with
    | fetch k => getValue k
    end

let withSuspending key tasks =
    let handle with indentLogHandler in
    let handle with runState SC.empty in
        let rec suspendingHandler =
            handler
            | fetch k => build k; resume (getValue k)
            end
            and build key =
            entry ();
            logln (cellToString key ++ " ");
            let done = get () in 
            match (tasks key, SC.mem key done) with
            | (Some (Task task), False) =>
               log "computing...\n";
               let value = getValue key in
               (* TODO: Rebuilder *)
               let newValue = handle task () with suspendingHandler
               in put (SC.add key done);
                  putValue key newValue
             | (None, _) => log "(i)\n"
             | (Some _, True) => log "already computed\n"
             end;
             exit ()
        in
        log ("Building " ++ cellToString key ++ " with suspending\n");
        build key

let withRestarting key tasks =
    let handle with indentLogHandler in
    (* TODO: Reuse chain from previous build *)
    let handle `q with runState [key] in
    (* let handle `q with runState [C "A1", C "A2", C3, B1, B2] in *)
    let handle `s with runState SC.empty in
        let rec neq dep x = match CellOrder.compare x dep with
                              | EQ => False
                              | _ => True
                              end
        and qInsert dep = match get `q () with
                          | [] => runtimeError "empty work queue\n"
                          | (curr::rest) => let after = (dep :: filter (neq dep) rest) @ [curr] in
                                            put `q after
                          end
        and restartingHandler =
            handler
            (* TODO: Rebuilder *)
            | fetch k => logln ("Fetching: " ++ cellToString k ++ "\n");
                         if (SC.mem k (get `s ())) then
                            resume (getValue k)
                         else match get `q () with
                              | [] => runtimeError "fetch from empty work queue\n"
                              | (curr::rest) =>  qInsert k; loop ()
                              end
            | return x => match get `q () with
                          | [] => runtimeError "return from empty work queue\n"
                          | (curr::rest) => logln ("Computed " ++ cellToString curr ++ "\n");
                                            put `s (SC.add curr (get `s ()));
                                            putValue curr x;
                                            loop ()
                          end
            end
        and loop () =
            (* logln ("Queue is: " ++ cellListToString (get `q ()) ++ " "); *)
            match get `q () with
            | [] => []
            | (key::keys) => match (tasks key, SC.mem key (get `s ())) with
                             | (Some (Task task), False) =>
                               log ("computing " ++ cellToString key ++ "\n");
                               let result = handle task () with restartingHandler in
                               result
                             | (None, _) =>
                                            log ("input " ++ cellToString key ++ "\n");
                                            put `s (SC.add key (get `s ()));
                                            put `q keys;
                                            key :: loop ()
                             | (Some _, True) =>
                                                log ("computed " ++ cellToString key ++ "\n");
                                                 put `q keys;
                                                 key :: loop ()
                             end
            end
        in
        let result = loop () in
        log ("Building " ++ cellToString key ++ " with restarting\n");
        printStr "Final queue:\n";
        printStr (cellListToString result ++ "\n"); ()

let _ =
    let s = FunStore () initState in
    ignore (handle `s in
        printIntList (List.map (getValue `s) [B1, B2, C3]); printStr "\n"
    with funStoreHandler sComp s);
    let (_, s') =
        handle
            (* withBusy B2 sprsh1 *)
            (* withSuspending B2 sprsh1 *)
            withRestarting B2 sprsh1
        with funStoreHandler sComp s in
    handle `s in
        printIntList (List.map (getValue `s) [B1, B2, C3]); printStr "\n"
    with funStoreHandler sComp s'
