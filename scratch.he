import Common
import Store
import Schedulers
import Rebuilders
import Spreadsheet
import Utils

import String
import List

open Common
open Store
open Schedulers
open Rebuilders
open Spreadsheet
open Utils

(* Chcielibyśmy mieć coś takiego: *)

(* let _ = *)
(*     handle buildA task *)
(*     with schedulerAndRebuilder *)

(* albo na przykład: *)

(* let _ = *)
(*     handle *)
(*         handle buildB task *)
(*         with scheduler *)
(*     with rebuilder *)

(* Zmodyfikowany przykład z Carte: *)

let sprsh1_B1 () = fetch (C "A1") + fetch (C "A2") + fetch C3
let sprsh1_B2 () = (fetch B1 + fetch B1) + fetch (C "A1")
let sprsh1_C3 () = 3 * fetch (C "A1") + fetch (C "A2")

let sprsh1 (cid: SpreadsheetCell) =
    match cid with
    | B1 => Some $ Task sprsh1_B1
    | B2 => Some $ Task sprsh1_B2
    | C3 => Some $ Task sprsh1_C3
    | _ => None
    end

let initState = fn key => match key with
                          | (C c) => if String.equal c "A1" then 10 else 20
                          | _ => 20
                          end

(* Chyba brak struktury podobnej do Applicative/statycznych zależności.
   Możemy jednak śledzić/track obliczane taski potomne początkowego: *)

(* Oblicz zadanie bez modyfikowania stanu (Carte 3.6) *)
let compute (Task task) =
    handle task () with
    | fetch k => getValue k
    end

let dumpStoreContents {I K: Type} {`s: StoreEff I K Int} (keys: List K) =
    printIntList (List.map (getValue `s) keys); printStr "\n"

let dumpGivenStoreContents (module T: KeyOrder) keys s =
    ignore(handle `s in
        dumpStoreContents keys
    with funStoreHandler T s)

(* let _ = *)
(*     let dump = dumpStoreContents CellOrder [B1, B2, C3] in *)
(*     let s = FunStore ((), []) initState in *)
(*     dump s; *)
(*     let (_, s') = *)
(*         handle *)
(*             (\* withBusy CellOrder sprsh1 B2 *\) *)
(*             withSuspending CellOrder dirtyBitRebuilder sprsh1 B2 *)
(*             (\* withRestarting CellOrder sprsh1 B2 *\) *)
(*         with funStoreHandler CellOrder s in *)
(*     dump s'; *)
(*     let (_, s'') = *)
(*         handle *)
(*             (\* withBusy CellOrder sprsh1 B2 *\) *)
(*             withSuspending CellOrder dirtyBitRebuilder sprsh1 B2 *)
(*             (\* withRestarting CellOrder sprsh1 B2 *\) *)
(*         with funStoreHandler CellOrder s' in *)
(*     dump s'' *)



let _ =
    let allDirtyInfo = (fn _ => True) in
    let allCleanInfo = (fn _ => False) in
    let allCleanButA1 x = match x with
                          | (C c) => String.equal c "A1" || allCleanInfo (C c)
                          | B1 => True | B2 => True | C3 => True
                          | x => allCleanInfo x
                          end in
    let dumpKeys = [C "A1", C "A2", B1, B2, C3] in
    let store = FunStore allDirtyInfo initState in
    handle
        dumpStoreContents dumpKeys;
        withSuspending CellOrder dirtyBitRebuilder sprsh1 B2;
        dumpStoreContents dumpKeys;
        (* Key A1 was modified, dirty bit updated appropriately *)
        putValue (C "A1") 20;
        modifyInfo (fn _ => allCleanButA1);
        withSuspending CellOrder dirtyBitRebuilder sprsh1 B2;
        dumpStoreContents dumpKeys
    with funStoreHandler CellOrder store

let excel {`a: StoreEff (Pair (SpreadsheetCell -> Bool)
                              (List SpreadsheetCell))
                        SpreadsheetCell
                        Int} = withRestarting CellOrder dirtyBitRebuilder

let _ =
    let allDirtyInfo = (fn _ => True) in
    let allCleanInfo = (fn _ => False) in
    let allCleanButA1 x = match x with
                          | (C c) => String.equal c "A1" || allCleanInfo (C c)
                          | B1 => True | B2 => True | C3 => True
                          | x => allCleanInfo x
                          end in
    let dumpKeys = [C "A1", C "A2", B1, B2, C3] in
    let store = FunStore (allDirtyInfo, []) initState in
    handle
        dumpStoreContents dumpKeys;
        excel sprsh1 B2;
        dumpStoreContents dumpKeys;
        (* Key A1 was modified, dirty bit updated appropriately *)
        putValue (C "A1") 20;
        modifyInfo (fn (_, r) => (allCleanButA1, r));
        excel sprsh1 B2;
        dumpStoreContents dumpKeys
    with funStoreHandler CellOrder store
