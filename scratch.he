import Common
import Store
import Schedulers
import Rebuilders
import Spreadsheet
import Utils

import String
import List

open Common
open Store
open Schedulers
open Rebuilders
open Spreadsheet
open Utils

(* Chcielibyśmy mieć coś takiego: *)

(* let _ = *)
(*     handle buildA task *)
(*     with schedulerAndRebuilder *)

(* albo na przykład: *)

(* let _ = *)
(*     handle *)
(*         handle buildB task *)
(*         with scheduler *)
(*     with rebuilder *)

(* Zmodyfikowany przykład z Carte: *)

let sprsh1_B1 () = fetch (C "A1") + fetch (C "A2") + fetch C3
let sprsh1_B2 () = (fetch B1 + fetch B1) + fetch (C "A1")
let sprsh1_C3 () = 3 * fetch (C "A1") + fetch (C "A2")

(*
                    A1  A2  B1  B2  C3
   Stan początkowy: 10  20  20  20  20
           Końcowy: 10  20  80  170 50
   A1 -> 20, start: 20  20  80  170 50
           Końcowy: 20  20  120 260 80
*)

let sprsh1 (cid: SpreadsheetCell) =
    match cid with
    | B1 => Some $ Task sprsh1_B1
    | B2 => Some $ Task sprsh1_B2
    | C3 => Some $ Task sprsh1_C3
    | _ => None
    end

let initState = fn key => match key with
                          | (C c) => if String.equal c "A1" then 10 else 20
                          | _ => 20
                          end

(* Oblicz zadanie bez modyfikowania stanu (Carte 3.6) *)
let compute (Task task) =
    handle task () with
    | fetch k => getValue k
    end

let dumpStoreContents {I K: Type} {`s: StoreEff I K Int} (keys: List K) =
    printIntList (List.map (getValue `s) keys); printStr "\n"

let dumpGivenStoreContents {T: Type} (module TM: Comparable T) keys s =
    ignore(handle `s in
        dumpStoreContents keys
    with funStoreHandler TM s)

let dumpKeys = [C "A1", C "A2", B1, B2, C3]

(* ------------------------------------------- Shake Demo ------------------------------------------- *)

let shake {K V: Type} {`s: StoreEff (VT K V) K V} (module KV: KeyValue K V) = withSuspending `s KV vtRebuilder

let shakeDemo () =
    let store = FunStore [] initState in
    handle
        dumpStoreContents dumpKeys;
        shake Spreadsheet sprsh1 B2;
        dumpStoreContents dumpKeys;
        (* Key A1 was modified *)
        putValue (C "A1") 20;
        dumpStoreContents dumpKeys;
        shake Spreadsheet sprsh1 B2;
        dumpStoreContents dumpKeys
    with funStoreHandler Spreadsheet.Key store

(* ------------------------------------------- Excel Demo ------------------------------------------- *)

let allDirtyInfo = (fn _ => True)
let allCleanInfo = (fn _ => False)
let allCleanButA1 x = match x with
                      | (C c) => String.equal c "A1" || allCleanInfo (C c)
                      | B1 => True | B2 => True | C3 => True
                      | x => allCleanInfo x
                      end

let excel {`s: StoreEff (Pair (SpreadsheetCell -> Bool)
                              (List SpreadsheetCell))
                        SpreadsheetCell
                        Int} = withRestarting Spreadsheet dirtyBitRebuilder

let excelDemo () =
    let store = FunStore (allDirtyInfo, []) initState in
    handle
        dumpStoreContents dumpKeys;
        excel sprsh1 B2;
        dumpStoreContents dumpKeys;
        (* Key A1 was modified, dirty bit updated appropriately *)
        putValue (C "A1") 20;
        modifyInfo (modifyFst (fn _ => allCleanButA1));
        excel sprsh1 B2;
        dumpStoreContents dumpKeys
    with funStoreHandler CellOrder store

let _ = shakeDemo ()
