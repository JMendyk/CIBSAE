
signature StoreEff (I: Type) (K: Type) (V: Type) =
| getInfo : Unit => I
| putInfo : I => Unit
| getValue : K => V
| putValue : K, V => Unit

(* RÃ³wnania:
   putInfo i; getInfo ()  ==  i
   putValue (k, v); getValue k  ==  v
*)

let modifyInfo f = putInfo (f (getInfo ()))
let incInfo () = modifyInfo (fn x => x + 1)
let decInfo () = modifyInfo (fn x => x - 1)

let rec getValueKV k kvs =
    match kvs with
    | [] => 0
    | (k', v')::kvs => if k = k' then v' else getValueKV k kvs
    end

let simpleInfoHandler i kvs =
    handler
    | getInfo () => fn i kvs => resume i i kvs
    | putInfo  i => fn _ kvs => resume () i kvs
    | getValue k => fn i kvs => resume (getValueKV k kvs) i kvs
    | putValue k v => fn i kvs => resume () i ((k, v)::kvs)
    | return   x => fn _ => x
    | finally f => f i kvs
    end

data FunStoreType (I: Type) (K: Type) (V: Type) = FunStore of I, (K -> V)

type Compare = sig
     type this: Type
     val compare: this -> this -> Ord
end

let funStoreHandler (module T: Compare) (FunStore i lookup) =
    handler
    | getInfo () => fn i lookup => resume i i lookup
    | putInfo  i => fn _ lookup => resume () i lookup
    | getValue k => fn i lookup => resume (lookup k) i lookup
    | putValue k v => fn i lookup =>
                         let lookup' x = match T.compare x k with
                                         | EQ => v
                                         | _ => lookup x
                                         end
                         in resume () i lookup'
    | return   x => fn i lookup => (x, FunStore i lookup)
    | finally f => f i lookup
    end
