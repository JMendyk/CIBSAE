import Common
import State
import Store
import Rebuilders
import Track
import Utils
import Logger
import Set

open Common
open State
open Store
open Rebuilders
open Track
open Utils
open Logger
open Set



let withBusy {I K V: Type} (module KV: KeyValue K V) {`a: StoreEff I K V} (tasks: Tasks K V) (key: K) =
    open KV in
    let handle with indentLogger in
    let rec busyHandler =
        handler
        | fetch k => build k; resume (getValue k)
        end
        and build (key: K) =
        entry ();
        logln (Key.toString key ++ "\n");
        match tasks key with
        | None => ()
        | Some (Task task) =>
               putValue key (handle task () with busyHandler)
        end;
        exit ()
    in
    logln ("Building " ++ Key.toString key ++ " with busy\n");
    build key

let withSuspending {IR K V: Type} {`ste: StoreEff IR K V} (module KV: KeyValue K V) (rebuilder: Rebuilder IR K V) (tasks: Tasks K V) (key: K) =
    open KV in
    let type ST = Set Key in
    let handle with indentLogger in
    let handle `set with evalState ST.empty in
    let handle `stir with embedState (getInfo `ste) (putInfo `ste) in
        let rec suspendingHandler =
                handler
                | fetch k => build k; resume (getValue k)
                end
            and build key =
            entry ();
            logln (Key.toString key ++ " ");
            match (tasks key, ST.mem key (get `set ())) with
            | (Some task, False) =>
               log "computing...\n";
               let value = getValue key in
               let handle `shh with suspendingHandler in
               let newTask = rebuilder `stir KV key value task in
               let newValue = run newTask in
               modifyState `set (ST.add key);
               putValue key newValue
             | (None, _) => log "(i)\n"
             | (Some _, True) => log "already computed\n"
             end;
             exit ()
        in
        log ("Building " ++ Key.toString key ++ " with suspending\n");
        build key

let embedHandler1 {IR K V: Type} (`ste: StoreEff (Pair IR (List K)) K V) = embedState (fst <.> getInfo `ste) (modifyInfo `ste <.> setFst)

let withRestarting {IR K V: Type} (module KV: KeyValue K V) {`ste: StoreEff (Pair IR (List K)) K V} (rebuilder: Rebuilder IR K V) (tasks: Tasks K V) (key: K) =
    open KV in
    let neq dep x = match Key.compare x dep with
                    | EQ => False
                    | _ => True
                    end in
    let type ST = Set Key in
    let handle with indentLogger in
    let oldChain = snd (getInfo ()) in
    let newChain = oldChain @ (if member Key key oldChain then [] else [key]) in
    let handle `q with evalState newChain in
    let handle `s with evalState ST.empty in
    let handle `stir with embedState (fst <.> getInfo `ste) (modifyInfo `ste <.> setFst) in
        let rec qInsert dep = match get `q () with
                              | [] => runtimeError "empty work queue\n"
                              | (curr::rest) => let after = (dep :: filter (neq dep) rest) @ [curr] in
                                                    put `q after
                              end
        and restartingHandler =
            handler
            | fetch k => logln ("Fetching: " ++ Key.toString k ++ "\n");
                         if (ST.mem k (get `s ())) then
                            resume (getValue `ste k)
                         else match get `q () with
                              | [] => runtimeError "fetch from empty work queue\n"
                              | (curr::rest) => log (Key.toString curr ++ " will be restarted\n"); qInsert k; loop ()
                              end
            | return x => match get `q () with
                          | [] => runtimeError "return from empty work queue\n"
                          | (curr::rest) => logln ("Finished " ++ Key.toString curr ++ "\n");
                                            modifyState `s (ST.add curr);
                                            put `q rest;
                                            putValue `ste curr x;
                                            curr :: loop ()
                          end
            end
        and loop () =
            match get `q () with
            | [] => []
            | (key::keys) =>
              match tasks key with
              | Some task => let value = getValue key in
                             let newTask = rebuilder `stir KV key value task in
                               handle run newTask with restartingHandler
              | None => log ("input " ++ Key.toString key ++ "\n");
                        modifyState `s (ST.add key);
                        put `q keys;
                        key :: loop ()
              end
            end
        in
        log ("Building " ++ Key.toString key ++ " with restarting\n");
        let resultChain = loop () in
        modifyInfo (modifySnd (fn _ => resultChain))
