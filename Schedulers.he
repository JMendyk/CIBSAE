import Common
import State
import Store
import Track
import Utils
import Logger
import Set

open Common
open State
open Store
open Track
open Utils
open Logger



let busy {I K V: Type} {`a: StoreEff I K V} (tasks: Tasks K V) (key: K) =
    let rec busyH =
        handler
        | fetch k => match tasks k with
                     | None => resume (getValue k)
                     | Some task => let handle with busyH in
                                    let v = run task in
                                        putValue k v;
                                        resume v
                     end
        end in
        handle fetch key with busyH

let suspending {IR K V: Type} {`ste: StoreEff IR K V} (module KV: KeyValue K V) (rebuilder: Rebuilder IR K V) (tasks: Tasks K V) (key: K) =
    open KV in
    let type ST = Set Key in
    let handle with indentLogger in
    let handle `set with evalState ST.empty in
    let handle `stir with embedState (getInfo `ste) (putInfo `ste) in
        let rec suspendingHandler =
                handler
                | fetch k => build k; resume (getValue k)
                end
            and build key =
            entry ();
            logln (Key.toString key ++ " ");
            match (tasks key, gets `set (ST.mem key)) with
            (* Input task *)
            | (None, _) => log "(i)\n"
            (* Task already built it this run *)
            | (Some _, True) => log "already built\n"
            (* Not built yet, rebuilder takes over *)
            | (Some task, False) =>
               log "building...\n";
               let value = getValue key in
               let handle with suspendingHandler in
               let newTask = rebuilder `stir KV key value task in
               let newValue = run newTask in
                   modify `set (ST.add key);
                   putValue key newValue
             end;
             exit ()
        in
        log ("Building " ++ Key.toString key ++ " with suspending scheduler\n");
        build key

let restarting {IR K V: Type} (module KV: KeyValue K V) {`ste: StoreEff (Pair IR (List K)) K V} (rebuilder: Rebuilder IR K V) (tasks: Tasks K V) (key: K) =
    open KV in
    let uniqPrepend x xs = x :: filter (not <.> Key.equals x) xs in
    let type ST = Set Key in
    let handle with indentLogger in
    let oldChain = snd (getInfo ()) in
    let newChain = oldChain @ (if member Key key oldChain then [] else [key]) in
    let handle `chain with evalState newChain in
    let handle `done with evalState ST.empty in
    let handle with embedState (fst <.> getInfo `ste) (modifyInfo `ste <.> setFst) in
    (* let qInsert dep s = match s with *)
    (*                     | [] => runtimeError "empty work queue\n" *)
    (*                     | (curr::rest) => uniqPrepend dep rest @ [curr] *)
    (*                     end in *)
    let qInsert dep s = let (curr, rest) = uncons s in
                            uniqPrepend dep rest @ [curr] in
    let rec restartingHandler =
            handler
            (* | fetch k => logln ("Fetching: " ++ Key.toString k ++ "\n"); *)
            (*              if gets `done (ST.mem k) then *)
            (*                 resume (getValue k) *)
            (*              else match get `chain () with *)
            (*                   | [] => runtimeError "fetch from empty work queue\n" *)
            (*                   | (curr::rest) => log (Key.toString curr ++ " will be restarted\n"); *)
            (*                                     modify `chain (qInsert k); *)
            (*                                     loop () *)
            (*                   end *)
            | fetch k => logln ("Fetching: " ++ Key.toString k ++ "\n");
                         if gets `done (ST.mem k) then
                            resume (getValue k)
                         else (let (curr, rest) = gets `chain uncons in
                                   log (Key.toString curr ++ " will be restarted\n");
                                   modify `chain (qInsert k);
                                   loop ())
            (* | return x => match get `chain () with *)
            (*               | [] => runtimeError "return from empty work queue\n" *)
            (*               | (curr::rest) => logln ("Finished " ++ Key.toString curr ++ "\n"); *)
            (*                                 modify `done (ST.add curr); *)
            (*                                 put `chain rest; *)
            (*                                 putValue curr x; *)
            (*                                 curr :: loop () *)
            (*               end *)
            | return x => let (curr, rest) = gets `chain uncons in
                              logln ("Finished " ++ Key.toString curr ++ "\n");
                              modify `done (ST.add curr);
                              put `chain rest;
                              putValue curr x;
                              curr :: loop ()
            end
        and loop () =
            match get `chain () with
            | [] => []
            | (key::keys) =>
              log ("Processing " ++ Key.toString key ++ "\n");
              match tasks key with
              (* Input task *)
              | None => log ("input " ++ Key.toString key ++ "\n");
                        modify `done (ST.add key);
                        put `chain keys;
                        key :: loop ()
              (* Not built yet, rebuilder takes over *)
              | Some task => let value = getValue key in
                             let newTask = rebuilder KV key value task in
                                 handle run newTask with restartingHandler
              end
            end
        in
        log ("Building " ++ Key.toString key ++ " with restarting scheduler\n");
        let resultChain = loop () in
        modifyInfo (mapSnd (fn _ => resultChain))
