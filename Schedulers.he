import Common
import State
import Store
import Rebuilders
import Utils
import Logger
import Set

open Common
open State
open Store
open Rebuilders
open Utils
open Logger
open Set



let withBusy {I V: Type} (module T: KeyOrder) {`a: StoreEff I T.this V} (tasks: Tasks T.this V) (key: T.this) =
    let handle with indentLogHandler in
    let rec busyHandler =
        handler
        | fetch k => build k; resume (getValue k)
        end
        and build (key: T.this) =
        entry ();
        logln (T.toString key ++ "\n");
        match tasks key with
        | None => ()
        | Some (Task task) =>
               putValue key (handle task () with busyHandler)
        end;
        exit ()
    in
    logln ("Building " ++ T.toString key ++ " with busy\n");
    build key

(* Tłumaczenie efektów stanowych na efekty związane z informacją w Store *)
let infoAsState {I K V: Type} {`s: StoreEff I K V} = embedState (getInfo `s) (putInfo `s)
(* alternatywnie: *)
(* let infoAsState = *)
(*     handler *)
(*     | get () => resume (getInfo ()) *)
(*     | put x => putInfo x; resume () *)
(*     end *)

let withSuspending {I V: Type} (module T: KeyOrder) {`a: StoreEff I T.this V} (rebuilder: Rebuilder I T.this V) (tasks: Tasks T.this V) (key: T.this) =
    let type ST = Set T in
    open T in
    let handle with indentLogHandler in
    let handle with evalState ST.empty in
        let rec suspendingHandler =
            handler
            | fetch k => build k; resume (getValue k)
            end
            and build key =
            entry ();
            logln (T.toString key ++ " ");
            let done = get () in
            match (tasks key, ST.mem key done) with
            | (Some task, False) =>
               log "computing...\n";
               let value = getValue key in
               let (Task newTask) = handle rebuilder key value task with infoAsState in
               let newValue = handle newTask () with suspendingHandler
               in put (ST.add key done);
                  putValue key newValue
             | (None, _) => log "(i)\n"
             | (Some _, True) => log "already computed\n"
             end;
             exit ()
        in
        log ("Building " ++ T.toString key ++ " with suspending\n");
        build key

let withRestarting {I V: Type} (module T: KeyOrder) {`a: StoreEff (Pair I (List T.this)) T.this V} (tasks: Tasks T.this V) (key: T.this) =
    let type ST = Set T in
    let handle with indentLogHandler in
    let oldChain = snd (getInfo ()) in
    let newChain = oldChain @ (if member T key oldChain then [] else [key]) in
    let handle `q with evalState newChain in
    (* let handle `q with runState [C "A1", C "A2", C3, B1, B2] in *)
    let handle `s with evalState ST.empty in
        let rec neq dep x = match T.compare x dep with
                              | EQ => False
                              | _ => True
                              end
        and qInsert dep = match get `q () with
                          | [] => runtimeError "empty work queue\n"
                          | (curr::rest) => let after = (dep :: filter (neq dep) rest) @ [curr] in
                                            put `q after
                          end
        and restartingHandler =
            handler
            (* TODO: Rebuilder *)
            | fetch k => (* logln ("Fetching: " ++ T.toString k ++ "\n"); *)
                         if (ST.mem k (get `s ())) then
                            resume (getValue k)
                         else match get `q () with
                              | [] => runtimeError "fetch from empty work queue\n"
                              | (curr::rest) => log (T.toString curr ++ " will be restarted\n"); qInsert k; loop ()
                              end
            | return x => match get `q () with
                          | [] => runtimeError "return from empty work queue\n"
                          | (curr::rest) => logln ("Finished " ++ T.toString curr ++ "\n");
                                            put `s (ST.add curr (get `s ()));
                                            putValue curr x;
                                            loop ()
                          end
            end
        and loop () =
            match get `q () with
            | [] => []
            | (key::keys) => match (tasks key, ST.mem key (get `s ())) with
                             | (Some (Task task), False) =>
                               log ("computing " ++ T.toString key ++ "\n");
                               let result = handle task () with restartingHandler in
                               result
                             | (None, _) =>
                                            log ("input " ++ T.toString key ++ "\n");
                                            put `s (ST.add key (get `s ()));
                                            put `q keys;
                                            key :: loop ()
                             | (Some _, True) =>
                                                 log ("computed " ++ T.toString key ++ "\n");
                                                 put `q keys;
                                                 key :: loop ()
                             end
            end
        in
        log ("Building " ++ T.toString key ++ " with restarting\n");
        let resultChain = loop () in
        modifyInfo (fn (i, _) => (i, resultChain))
