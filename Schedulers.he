import Common
import State
import Store
import Rebuilders
import Utils
import Logger
import Set

open Common
open State
open Store
open Rebuilders
open Utils
open Logger
open Set



let withBusy {I V: Type} (module T: KeyOrder) {`a: StoreEff I T.this V} (tasks: Tasks T.this V) (key: T.this) =
    let handle with indentLogHandler in
    let rec busyHandler =
        handler
        | fetch k => build k; resume (getValue k)
        end
        and build (key: T.this) =
        entry ();
        logln (T.toString key ++ "\n");
        match tasks key with
        | None => ()
        | Some (Task task) =>
               putValue key (handle task () with busyHandler)
        end;
        exit ()
    in
    logln ("Building " ++ T.toString key ++ " with busy\n");
    build key

let withSuspending {I V: Type} (module T: KeyOrder) {`a: StoreEff I T.this V} (rebuilder: Rebuilder I T.this V) (tasks: Tasks T.this V) (key: T.this) =
    let type ST = Set T in
    let embedHandler = embedState (getInfo `a) (putInfo `a)
    let handle with indentLogHandler in
    let handle with evalState ST.empty in
        let rec suspendingHandler =
            handler
            | fetch k => build k; resume (getValue k)
            end
            and build key =
            entry ();
            logln (T.toString key ++ " ");
            match (tasks key, ST.mem key (get ())) with
            | (Some task, False) =>
               log "computing...\n";
               let value = getValue key in
               let (Task newTask) = handle rebuilder key value task with embedHandler in
               let newValue = handle newTask () with suspendingHandler
               in modifyState (ST.add key);
                  putValue key newValue
             | (None, _) => log "(i)\n"
             | (Some _, True) => log "already computed\n"
             end;
             exit ()
        in
        log ("Building " ++ T.toString key ++ " with suspending\n");
        build key

let withRestarting {IR V: Type} (module T: KeyOrder) {`a: StoreEff (Pair IR (List T.this)) T.this V} (rebuilder: Rebuilder IR T.this V) (tasks: Tasks T.this V) (key: T.this) =
    let type ST = Set T in
    let handle with indentLogHandler in
    let oldChain = snd (getInfo ()) in
    let newChain = oldChain @ (if member T key oldChain then [] else [key]) in
    let embedHandler = embedState (fst <.> getInfo `a) (modifyInfo `a <.> setFst) in
    let handle `q with evalState newChain in
    let handle `s with evalState ST.empty in
        let rec neq dep x = match T.compare x dep with
                              | EQ => False
                              | _ => True
                              end
        and qInsert dep = match get `q () with
                          | [] => runtimeError "empty work queue\n"
                          | (curr::rest) => let after = (dep :: filter (neq dep) rest) @ [curr] in
                                            put `q after
                          end
        and restartingHandler =
            handler
            | fetch k => logln ("Fetching: " ++ T.toString k ++ "\n");
                         if (ST.mem k (get `s ())) then
                            resume (getValue k)
                         else match get `q () with
                              | [] => runtimeError "fetch from empty work queue\n"
                              | (curr::rest) => log (T.toString curr ++ " will be restarted\n"); qInsert k; loop ()
                              end
            | return x => match get `q () with
                          | [] => runtimeError "return from empty work queue\n"
                          | (curr::rest) => logln ("Finished " ++ T.toString curr ++ "\n");
                                            modifyState `s (ST.add curr);
                                            put `q rest;
                                            putValue curr x;
                                            curr :: loop ()
                          end
            end
        and loop () =
            match get `q () with
            | [] => []
            | (key::keys) =>
              match tasks key with
              | Some task => let value = getValue key in
                               let (Task newTask) = handle rebuilder key value task
                                                    with embedHandler in
                               handle newTask () with restartingHandler
              | None => log ("input " ++ T.toString key ++ "\n");
                        modifyState `s (ST.add key);
                        put `q keys;
                        key :: loop ()
              end
            end
        in
        log ("Building " ++ T.toString key ++ " with restarting\n");
        let resultChain = loop () in
        modifyInfo (fn (i, _) => (i, resultChain))
